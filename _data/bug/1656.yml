+p_xml: 'version="1.0" encoding="UTF-8" standalone="yes" '
+directive: DOCTYPE bugzilla SYSTEM "http://bugzilla.fieldtriptoolbox.org/page.cgi?id=bugzilla.dtd"
bugzilla:
  +@version: 4.4.1
  +@urlbase: http://bugzilla.fieldtriptoolbox.org/
  +@maintainer: r.oostenveld@donders.ru.nl
  bug:
    bug_id: "1656"
    creation_ts: 2012-08-16 09:53:00 +0200
    short_desc: input variable name should be consistent with the data type
    delta_ts: 2014-03-26 12:57:56 +0100
    reporter_accessible: "1"
    cclist_accessible: "1"
    classification_id: "1"
    classification: Unclassified
    product: FieldTrip
    component: core
    version: unspecified
    rep_platform: PC
    op_sys: Mac OS
    bug_status: NEW
    resolution:
    see_also: http://bugzilla.fcdonders.nl/show_bug.cgi?id=2513
    bug_file_loc:
    status_whiteboard:
    keywords:
    priority: P3
    bug_severity: normal
    target_milestone: '---'
    everconfirmed: "1"
    reporter:
      +content: r.oostenveld
      +@name: Robert Oostenveld
    assigned_to: fieldtriptoolbox
    cc: roemer.van.der.meij
    comment_sort_order: oldest_to_newest
    long_desc:
      - +@isprivate: "0"
        commentid: "7016"
        comment_count: "0"
        who:
          +content: r.oostenveld
          +@name: Robert Oostenveld
        bug_when: 2012-08-16 09:53:59 +0200
        thetext: "I noticed that sourceplot uses\n\nfunction [cfg] = ft_sourceplot(cfg, data)\n\nand also in its documentation \n\n% To facilitate data-handling and distributed computing with the peer-to-peer\n% module, this function has the following option:\n%   cfg.inputfile   =  ...\n% If you specify this option the input data will be read from a *.mat\n% file on disk. This mat files should contain only a single variable named 'data',\n% corresponding to the input structure.\n\nIt makes more sense to have it use either \"source\", \"mri\", \"volume\" or \"segment\" as input variable, as those are documented as output variables for the preceding functions. \n\nIt would be good to review this issue on input and output variable naming and add it to the code  guidelines at http://fieldtrip.fcdonders.nl/code_guidelines\n\nI suggest something like:\n\n===== Variable names ====  \n\nIf you write a new function, please use input and output variable names that are consistent with their use in other fieldtrip code and documentation. Especially the reference documentation (i.e. \"help functionname\") should be consistent w.r.t. variable naming.\n\n  * data\n  * source\n  * mri\n  * segment\n  * freq\n  * timelock\n\nSee ft_datatype and the ft_datatype_xxx functions for the most commonly used names."
      - +@isprivate: "0"
        commentid: "7017"
        comment_count: "1"
        who:
          +content: roemer.van.der.meij
          +@name: Roemer van der Meij
        bug_when: 2012-08-16 11:10:47 +0200
        thetext: "This will be difficult to do for single/multi/topoplotER, as freq and timelock are very common inputs. Shall we skip these for the time being? We wanted to change the interface to those anyways by restructuring/slightly-redoing them. \n\nAlso see http://fieldtrip.fcdonders.nl/development/restructure_and_rework_all_visualization_functions"
      - +@isprivate: "0"
        commentid: "7022"
        comment_count: "2"
        who:
          +content: r.oostenveld
          +@name: Robert Oostenveld
        bug_when: 2012-08-16 11:30:01 +0200
        thetext: "(In reply to comment #1)\n\nThere are more functions that allow multiple inputs. My suggestion is that the code should at least reflect one of them. \n\nThe bug as I see it is that ft_sourceplot uses \"data\" as input, whereas data usually refers to the output of ft_preprocessing. The input variable source makes most sense if you ask me.\n\nRather than the present\n\n  Use as\n    ft_sourceplot(cfg, data)\n  where the input data can contain an anatomical MRI, functional source\n  reconstruction results and statistical data, which all have to be\n  interpolated on the same 3-d grid.\n\nwe can document it as\n\n%  Use as\n%    ft_sourceplot(cfg, source)\n%  where the input can contain a source reconstruction, statistical results \n%  and/or an anatomical MRI, which all have to be interpolated on the same 3-d grid.\n\nAlternatively we can elaborate like this\n\n%  Use as\n%    ft_sourceplot(cfg, mri)\n%    ft_sourceplot(cfg, source)\n%    ft_sourceplot(cfg, stat)\n%    ft_sourceplot(cfg, segment)\n% where ... \n\nThe second style would provide a better relation to the \"see also\" section. This is already being used for example in \n\n% Use as\n%   [interp] = ft_sourceinterpolate(cfg, source, anatomy)\n%   [interp] = ft_sourceinterpolate(cfg, stat, anatomy)\n% where\n%   source  is the output of FT_SOURCEANALYSIS\n%   stat    is the output of FT_SOURCESTATISTICS\n%   anatomy is the output of FT_READ_MRI or one of the FT_VOLUMExxx functions, \n%           a cortical sheet that was read with FT_READ_HEADSHAPE, or a regular\n%           3D grid created with FT_PREPARE_SOURCEMODEL. \n% and cfg is a structure with any of the following fields\n\nNote that I do also think that it won't be possible everywhere. But going over the ref/help documentation once to clean it up as much as possible should be doable."
      - +@isprivate: "0"
        commentid: "7023"
        comment_count: "3"
        who:
          +content: r.oostenveld
          +@name: Robert Oostenveld
        bug_when: 2012-08-16 11:46:59 +0200
        thetext: "I used the following linux command line code\n\nfor file in ft_*.m ; do  awk 'BEGIN{ p=0 }; /Use as/ {p=1} ; /%$/ {p=0} ; {if (p==1)  print $0 };' $file | head -10 >> out.txt; echo \"\" >> out.txt; echo \"----------------------------------------------\" >> out.txt; echo \"\" >> out.txt; done\n\nto try and get the relevant section from all FT main functions (see below). I suggest we discuss it and decide on the best style in the next meeting.\n\n----------------------------------------------\n\n% Use as\n%   ft_analysisprotocol(cfg, data)\n\n----------------------------------------------\n\n% Use as\n%   data = ft_appenddata(cfg, data1, data2, data3, ...)\n% where the configuration can be empty.\n\n----------------------------------------------\n\n% Use as\n%  combined = ft_appendfreq(cfg, freq1, freq2, ...)\n\n----------------------------------------------\n\n% Use as\n%   combined = ft_appendsource(cfg, source1, source2, ...)\n\n----------------------------------------------\n\n% Use as\n%   [spike] = ft_appendspike(cfg, spike1, spike2, spike3, ...)\n% where the input structures come from FT_READ_SPIKE, or as\n%   [data]  = ft_appendspike(cfg, data, spike1, spike2, ...)\n% where the first data structure is the result of FT_PREPROCESSING\n% and the subsequent ones come from FT_READ_SPIKE.\n\n----------------------------------------------\n\n% Use as\n%   combined = ft_appendtimelock(cfg, timelock1, timelock2, ...)\n\n----------------------------------------------\n\n% Use as\n%   [cfg, artifact] = ft_artifact_clip(cfg)\n% with the configuration options\n%   cfg.dataset \n%   cfg.headerfile \n%   cfg.datafile\n\n----------------------------------------------\n\n% Use as\n%   [cfg, artifact] = ft_artifact_ecg(cfg)\n% with the configuration options\n%   cfg.dataset \n%   cfg.headerfile \n%   cfg.datafile\n\n----------------------------------------------\n\n% Use as\n%   [cfg, artifact] = ft_artifact_eog(cfg)\n% with the configuration options\n%   cfg.dataset \n%   cfg.headerfile \n%   cfg.datafile\n\n----------------------------------------------\n\n% Use as\n%   [cfg, artifact] = ft_artifact_jump(cfg)\n% with the configuration options\n%   cfg.dataset \n%   cfg.headerfile \n%   cfg.datafile\n\n----------------------------------------------\n\n% Use as\n%   [cfg, artifact] = ft_artifact_muscle(cfg)\n% with the configuration options\n%   cfg.dataset\n%   cfg.headerfile\n%   cfg.datafile\n\n----------------------------------------------\n\n% Use as\n%   [cfg, artifact] = ft_artifact_threshold(cfg)\n% with the configuration options\n%   cfg.dataset\n%   cfg.headerfile\n%   cfg.datafile\n\n----------------------------------------------\n\n% Use as\n%   [cfg, artifact] = ft_artifact_zvalue(cfg)\n% or\n%   [cfg, artifact] = ft_artifact_zvalue(cfg, data)\n\n----------------------------------------------\n\n\n----------------------------------------------\n\n% Use as\n%   [dataout] = ft_channelnormalise(cfg, data)\n\n----------------------------------------------\n\n% Use as\n%   [interp] = ft_channelrepair(cfg, data)\n\n----------------------------------------------\n\n% Use as:\n%   channel = ft_channelselection(desired, datachannel)\n\n----------------------------------------------\n\n% Use as\n%   ft_clusterplot(cfg, stat)\n\n----------------------------------------------\n\n% Use as\n%   [data] = ft_combineplanar(cfg, data)\n% where data contains an averaged planar gradient (either ERF or TFR).\n\n----------------------------------------------\n\n% Use as\n%   list = add_mex_source(list, directory, relName, includePlatform, excludePlatform, extras)\n% Use as\n%  compile_mex_list(L, baseDir)\n\n----------------------------------------------\n\n% Use as\n%   [comp] = ft_componentanalysis(cfg, data)\n\n----------------------------------------------\n\n% Use as\n%  outdata = ft_componentclassification(cfg, comp) \n% where comp is the output of FT_COMPONENTANALYSIS and cfg is a       \n% configuration structure that should contain \n\n----------------------------------------------\n\n% Use as\n%   [stat] = ft_conjunctionanalysis(cfg, stat1, stat2, .., statN)\n\n----------------------------------------------\n\n% Use as\n%   stat = ft_connectivityanalysis(cfg, data)\n%   stat = ft_connectivityanalysis(cfg, timelock)\n%   stat = ft_connectivityanalysis(cfg, freq)\n%   stat = ft_connectivityanalysis(cfg, source)\n% where the first input argument is a configuration structure (see\n% below) and the second argument is the output of FT_PREPROCESSING,\n% FT_TIMELOCKANLAYSIS, FT_FREQANALYSIS, FT_MVARANALYSIS,\n% FT_SOURCEANALYSIS. The different connectivity\n% metrics are supported only for specific datatypes (see below). \n\n----------------------------------------------\n\n% Use as\n%   ft_connectivityplot(cfg, data)\n\n----------------------------------------------\n\n% Use as\n%   [data] = ft_connectivitysimulation(cfg)\n\n----------------------------------------------\n\n% Use as\n%   cfg = ft_databrowser(cfg)\n% where the configuration structure contains the reference to the dataset\n% on your hard disk (see below), or use as\n%   cfg = ft_databrowser(cfg, data)\n% where the input data is a structure as obtained from FT_PREPROCESSING or\n% from FT_COMPONENTANALYSIS.\n\n----------------------------------------------\n\n\n----------------------------------------------\n\n% Use as\n%   [cfg] = ft_definetrial(cfg)\n% where the configuration structure should contain either\n%   cfg.trialdef   = structure with details of trial definition, see below\n%   cfg.trialfun   = function name, see below (default = 'ft_trialfun_general')\n% and also\n%   cfg.dataset    = pathname to dataset from which to read the events\n% \n% A call to FT_DEFINETRIAL results in the trial definition \"trl\" being\n% added to the output configuration structure. The trials are defined\n\n----------------------------------------------\n\n% Use as\n%   [dataout] = ft_denoise_pca(cfg, data) \n% or \n%   [dataout] = ft_denoise_pca(cfg, data, refdata)\n\n----------------------------------------------\n\n% Use as\n%   [data] = ft_denoise_synthetic(cfg, data);\n\n----------------------------------------------\n\n% Use as outdata = ft_recompile(cfg, indata) where indata is <<describe\n% the type of data or where it comes from>> and cfg is a configuratioun\n% structure that should contain:\n\n----------------------------------------------\n\n% Use as\n%   [source] = ft_dipolefitting(cfg, data)\n\n----------------------------------------------\n\n% Use as\n%   data = ft_dipolesimulation(cfg)\n\n----------------------------------------------\n\n\n----------------------------------------------\n\n\n----------------------------------------------\n\n% Use as\n%   [elec] = ft_electroderealign(cfg)\n\n----------------------------------------------\n\n% Use as\n%  outdata = ft_examplefunction(cfg, indata) \n% where indata is <<describe the type of data or where it comes from>> \n% and cfg is a configuratioun structure that should contain \n\n----------------------------------------------\n\n% Use as\n%   [freq] = ft_freqanalysis(cfg, data)\n\n----------------------------------------------\n\n% Use as\n%   [freq] = ft_freqanalysis(cfg, data), with cfg.method = 'mvar'\n\n----------------------------------------------\n\n% Use as\n%    [freq] = ft_freqbaseline(cfg, freq)\n% where the freq data comes from FT_FREQANALYSIS and the configuration\n% should contain\n%   cfg.baseline     = [begin end] (default = 'no')\n%   cfg.baselinetype = 'absolute', 'relchange' or 'relative' (default = 'absolute')\n%   cfg.parameter    = field for which to apply baseline normalization, or\n%                      cell array of strings to specify multiple fields to normalize\n%                      (default = 'powspctrm')\n\n----------------------------------------------\n\n% Use as\n%   [freq] = ft_freqcomparison(cfg, dataset1, dataset2);\n\n----------------------------------------------\n\n% Use as\n%   [freq] = ft_freqdescriptives(cfg, freq)\n%   [freq] = ft_freqdescriptives(cfg, freqmvar)\n\n----------------------------------------------\n\n% Use as\n%   [grandavg] = ft_freqgrandaverage(cfg, freq1, freq2, freq3...)\n\n----------------------------------------------\n\n% Use as\n%   freq = ft_freqinterpolate(cfg, freq)\n% where freq is the output of FT_FREQANALYSIS or FT_FREQDESCRIPTIVES and the\n% configuration may contain\n%   cfg.method   = 'nan', 'linear' (default = 'nan')\n%   cfg.foilim   = Nx2 matrix with begin and end of each interval to be\n%                  interpolated (default = [49 51; 99 101; 149 151])\n\n----------------------------------------------\n\n% Use as\n%   [data] = ft_freqsimulation(cfg)\n\n----------------------------------------------\n\n% Use as\n%   [stat] = ft_freqstatistics(cfg, freq1, freq2, ...)\n% where the input data is the result from FT_FREQANALYSIS, FT_FREQDESCRIPTIVES\n% or from FT_FREQGRANDAVERAGE.\n\n----------------------------------------------\n\n% Use as\n%   grad = ft_headmovement(cfg)\n% where the configuration should contain\n%   cfg.dataset      = string with the filename\n%   cfg.trl          = Nx3 matrix with the trial definition, see FT_DEFINETRIAL\n%   cfg.numclusters  = number of segments with constant headposition in which to split the data (default = 12)\n\n----------------------------------------------\n\n% Use as\n%   [cfg] = ft_interactiverealign(cfg)\n\n----------------------------------------------\n\n% Use as\n%   [lrp] = ft_lateralizedpotential(cfg, avgL, avgR)\n\n----------------------------------------------\n\n% Use as\n%   ft_layoutplot(cfg, data)\n\n----------------------------------------------\n\n% Use as\n%    [interp] = ft_megplanar(cfg, data)\n\n----------------------------------------------\n\n% Use as\n%   [interp] = ft_megrealign(cfg, data)\n\n----------------------------------------------\n\n% Use as\n%   ft_movieplotER(cfg, timelock)\n% where the input data is from FT_TIMELOCKANALYSIS and the configuration\n% can contain\n%   cfg.parameter    = string, parameter that is color coded (default = 'avg')\n%   cfg.xlim         = 'maxmin' or [xmin xmax] (default = 'maxmin')\n%   cfg.zlim         = 'maxmin', 'maxabs' or [zmin zmax] (default = 'maxmin')\n%   cfg.samperframe  = number, samples per fram (default = 1)\n%   cfg.framespersec = number, frames per second (default = 5)\n%   cfg.framesfile   = [], no file saved, or 'string', filename of saved frames.mat (default = []);\n\n----------------------------------------------\n\n% Use as\n%   ft_movieplotTFR(cfg, data)\n% where the input data comes from FT_FREQANALYSIS or FT_FREQDESCRIPTIVES and the\n% configuration is a structure that can contain\n%   cfg.parameter    = string, parameter that is color coded (default = 'avg')\n%   cfg.xlim         = selection boundaries over first dimension in data (e.g., time)\n%                          'maxmin' or [xmin xmax] (default = 'maxmin')\n%   cfg.ylim         = selection boundaries over second dimension in data (e.g., freq)\n%                          'maxmin' or [xmin xmax] (default = 'maxmin')\n%   cfg.zlim         = plotting limits for color dimension, 'maxmin',\n\n----------------------------------------------\n\n% Use as\n%   ft_multiplotCC(cfg, data)\n\n----------------------------------------------\n\n% Use as\n%   ft_multiplotER(cfg, data)\n% or\n%   ft_multiplotER(cfg, data, data2, ..., dataN)\n\n----------------------------------------------\n\n% Use as\n%   ft_multiplotTFR(cfg, data)\n\n----------------------------------------------\n\n% Use as\n%   [mvardata] = ft_mvaranalysis(cfg, data)\n\n----------------------------------------------\n\n% Use as\n%   ft_neighbourplot(cfg)\n% or as\n%   ft_neighbourplot(cfg, data)\n\n----------------------------------------------\n\n% Use as\n%   stat = ft_networkanalysis(cfg, data)\n\n----------------------------------------------\n\n% Use as\n%   [atlas] = ft_prepare_atlas(cfg)\n\n----------------------------------------------\n\n% Use as\n%   [vol] = ft_prepare_bemmodel(cfg, mri), or\n%   [vol] = ft_prepare_bemmodel(cfg, seg), or\n%   [vol] = ft_prepare_bemmodel(cfg, vol), or\n%   [vol] = ft_prepare_bemmodel(cfg)\n\n----------------------------------------------\n\n% Use as\n%   vol = ft_prepare_concentricspheres(cfg)\n\n----------------------------------------------\n\n% Use as\n%   vol = ft_prepare_headmodel(cfg)       or\n%   vol = ft_prepare_headmodel(cfg, bnd)  with the output of FT_PREPARE_MESH\n%   vol = ft_prepare_headmodel(cfg, seg)  with the output of FT_VOLUMESEGMENT\n%   vol = ft_prepare_headmodel(cfg, elec) with the output of FT_READ_SENS\n%   vol = ft_prepare_headmodel(cfg, vol)  with the output of FT_READ_VOL\n% Use as\n%  [pnt, tri] = msphere(M)\n% Use as\n%   [pnt, tri] = remove_double_vertices(pnt, tri)\n\n----------------------------------------------\n\n% Use as\n%   lay = ft_prepare_layout(cfg, data)\n\n----------------------------------------------\n\n% Use as\n%   [grid] = ft_prepare_leadfield(cfg, data);\n\n----------------------------------------------\n\n% Use as\n%   vol = ft_prepare_localspheres(cfg, seg), or\n%   vol = ft_prepare_localspheres(cfg, mri), or\n%   vol = ft_prepare_localspheres(cfg)\n\n----------------------------------------------\n\n% Use as\n%   bnd = ft_prepare_mesh(cfg, mri)\n\n----------------------------------------------\n\n% Use as\n%   bnd = ft_prepare_mesh(cfg, data)\n\n----------------------------------------------\n\n% Use as\n%   neighbours = ft_prepare_neighbours(cfg, data)\n\n----------------------------------------------\n\n% Use as\n%   vol = ft_prepare_singleshell(cfg, seg), or\n%   vol = ft_prepare_singleshell(cfg, mri), or\n%   vol = ft_prepare_singleshell(cfg)\n\n----------------------------------------------\n\n% Use as\n%   grid = prepare_prepare_sourcemodel(cfg)\n\n----------------------------------------------\n\n% Use as\n%   [data] = ft_preprocessing(cfg)\n% or\n%   [data] = ft_preprocessing(cfg, data)\n\n----------------------------------------------\n\n% Use as\n%   [info, timelock, freq, summary, headpos] = ft_qualitycheck(cfg)\n% where info contains the dataset properties, timelock the timelocked data, \n% freq the powerspectra, summary the mean descriptives, and headpos the\n% headpositions throughout the recording\n\n----------------------------------------------\n\n% Use as\n%   [ev] = ft_recodeevent(cfg, data)\n% where cfg is a structure with configuration settings and data contains the\n% (nested) configuration that describes the original trial definition and\n% event structure.\n\n----------------------------------------------\n\n% Use as\n%   data = ft_redefinetrial(cfg, data)\n% where the input data should correspond to the output of FT_PREPROCESSING and\n% the configuration should be specified as explained below. Note that some\n% options are mutually exclusive, and require two calls to this function to\n% avoid confucion about the order in which they are applied.\n\n----------------------------------------------\n\n% Use as\n%   timelock = ft_regressconfound(cfg, timelock)\n% or as\n%   freq     = ft_regressconfound(cfg, freq)\n% or as\n%   source   = ft_regressconfound(cfg, source)\n\n----------------------------------------------\n\n% Use as\n%   cfg = ft_rejectartifact(cfg)\n% with the cfg as obtained from FT_DEFINETRIAL, or as\n%   data = ft_rejectartifact(cfg, data)\n% with the data as obtained from FT_PREPROCESSING\n\n----------------------------------------------\n\n% Use as\n%    [data] = ft_rejectcomponent(cfg, comp)\n% or as\n%    [data] = ft_rejectcomponent(cfg, comp, data)\n\n----------------------------------------------\n\n% Use as\n%   [data] = ft_rejectvisual(cfg, data)\n\n----------------------------------------------\n\n% Use as\n%   [data] = ft_resampledata(cfg, data)\n\n----------------------------------------------\n\n% Use as\n%   [data] = ft_scalpcurrentdensity(cfg, data)\n% or\n%   [timelock] = ft_scalpcurrentdensity(cfg, timelock)\n% where the input data is obtained from FT_PREPROCESSING or from\n% FT_TIMELOCKANALYSIS. The output data has the same format as the input\n% and can be used in combination with most other FieldTrip functions\n% such as FT_FREQNALYSIS or FT_TOPOPLOTER.\n\n----------------------------------------------\n\n% Use as\n%   [sensor] = ft_sensorrealign(cfg) or\n%   [sensor] = ft_sensorrealign(cfg, sensor)\n% where you specify the electrodes or gradiometers in the configuration\n% structure (see below) or as the second input argument.\n\n----------------------------------------------\n\n% Use as\n%   ft_singleplotER(cfg, data)\n% or\n%   ft_singleplotER(cfg, data1, data2, ..., datan)\n\n----------------------------------------------\n\n% Use as\n%   ft_singleplotTFR(cfg,data)\n\n----------------------------------------------\n\n% Use as\n%   ft_sliceinterp(cfg, interp)\n%      or\n%   [rgbimage] = ft_sliceinterp(cfg, interp), rgbimage is the monatage image\n\n----------------------------------------------\n\n% Use as either\n%   [source] = ft_sourceanalysis(cfg, freq)\n%   [source] = ft_sourceanalysis(cfg, timelock)\n\n----------------------------------------------\n\n% Use as\n%   [source] = ft_sourcedescriptives(cfg, source)\n\n----------------------------------------------\n\n% Use as\n%  [grandavg] = ft_sourcegrandaverage(cfg, source1, source2, ...)\n\n----------------------------------------------\n\n% Use as\n%   [interp] = ft_sourceinterpolate(cfg, source, anatomy)\n%   [interp] = ft_sourceinterpolate(cfg, stat, anatomy)\n% where\n%   source  is the output of FT_SOURCEANALYSIS\n%   stat    is the output of FT_SOURCESTATISTICS\n%   anatomy is the output of FT_READ_MRI or one of the FT_VOLUMExxx functions, \n%           a cortical sheet that was read with FT_READ_HEADSHAPE, or a regular\n%           3D grid created with FT_PREPARE_SOURCEMODEL. \n% and cfg is a structure with any of the following fields\n\n----------------------------------------------\n\n% Use as\n%   ft_sourcemovie(cfg, source)\n% where the input source data is obtained from FT_SOURCEANALYSIS and cfg is\n% a configuratioun structure that should contain\n\n----------------------------------------------\n\n% Use as\n%   ft_sourceplot(cfg, data)\n% where the input data can contain an anatomical MRI, functional source\n% reconstruction results and/or statistical data. If both anatomical and\n% functional/statistical data is provided as input, they should be\n% represented or interpolated on the same same 3-D grid, e.g. using\n% FT_SOURCEINTERPOLATE.\n\n----------------------------------------------\n\n% Use as\n%   [stat] = ft_sourcestatistics(cfg, source1, source2, ...)\n% where the input data is the result from FT_SOURCEANALYSIS, FT_SOURCEDESCRIPTIVES\n% or FT_SOURCEGRANDAVERAGE.  The source structures should be spatially alligned\n% to each other and should have the same positions for the source grid.\n\n----------------------------------------------\n\n% Use as\n%  ft_sourcewrite(cfg, source) \n% where source is a source structure obtained after FT_SOURCEANALYSIS and \n% cfg is a configuratioun structure that should contain \n\n----------------------------------------------\n\n% Use as\n%   stat = ft_timelockstatistics(cfg, data1, data2, data3, ...)\n%   stat = ft_freqstatistics    (cfg, data1, data2, data3, ...)\n%   stat = ft_sourcestatistics  (cfg, data1, data2, data3, ...)\n% where the data is obtained from FT_TIMELOCKANALYSIS, FT_FREQANALYSIS\n% or FT_SOURCEANALYSIS respectively, or from FT_TIMELOCKGRANDAVERAGE,\n% FT_FREQGRANDAVERAGE or FT_SOURCEGRANDAVERAGE respectively.\n\n----------------------------------------------\n\n% Use as\n%   stat = ft_timelockstatistics(cfg, data1, data2, data3, ...)\n%   stat = ft_freqstatistics    (cfg, data1, data2, data3, ...)\n%   stat = ft_sourcestatistics  (cfg, data1, data2, data3, ...)\n\n----------------------------------------------\n\n% Use as\n%   stat = ft_timelockstatistics(cfg, data1, data2, data3, ...)\n%   stat = ft_freqstatistics    (cfg, data1, data2, data3, ...)\n%   stat = ft_sourcestatistics  (cfg, data1, data2, data3, ...)\n\n----------------------------------------------\n\n% Use as\n%   stat = ft_timelockstatistics(cfg, data1, data2, data3, ...)\n%   stat = ft_freqstatistics    (cfg, data1, data2, data3, ...)\n%   stat = ft_sourcestatistics  (cfg, data1, data2, data3, ...)\n\n----------------------------------------------\n\n% Use as\n%   [output]          = ft_stratify(cfg, input1, input2, ...), or\n%   [output, binaxis] = ft_stratify(cfg, input1, input2, ...)\n\n----------------------------------------------\n\n\n----------------------------------------------\n\n% Use as\n%    [timelock] = ft_timelockbaseline(cfg, timelock)\n% where the timelock data comes from FT_TIMELOCKANALYSIS and the\n% configuration should contain\n%   cfg.baseline     = [begin end] (default = 'no')\n%   cfg.channel      = cell-array, see FT_CHANNELSELECTION\n%   cfg.parameter    = field for which to apply baseline normalization, or\n%                      cell array of strings to specify multiple fields to normalize\n%                      (default = 'avg')\n% To facilitate data-handling and distributed computing with the peer-to-peer\n\n----------------------------------------------\n\n% Use as\n%   [grandavg] = ft_timelockgrandaverage(cfg, avg1, avg2, avg3, ...)\n\n----------------------------------------------\n\n% Use as\n%   [stat] = ft_timelockstatistics(cfg, timelock1, timelock2, ...)\n% where the input data is the result from either FT_TIMELOCKANALYSIS or\n% FT_TIMELOCKGRANDAVERAGE.\n\n----------------------------------------------\n\n% Use as\n%  ft_topoplotCC(cfg, freq)\n\n----------------------------------------------\n\n% Use as\n%   ft_topoplotER(cfg, timelock)\n% or\n%   ft_topoplotER(cfg, freq)\n\n----------------------------------------------\n\n% Use as\n%   ft_topoplotIC(cfg, comp)\n% where the input comp structure should be obtained from FT_COMPONENTANALYSIS.\n\n----------------------------------------------\n\n% Use as\n%   ft_topoplotTFR(cfg, freq)\n\n----------------------------------------------\n\n\n----------------------------------------------\n\n% Use as\n%   [volume] = ft_volumedownsample(cfg, mri)\n% where the input mri should be a single anatomical volume that was\n% for example read with FT_READ_MRI or should be a volumetric source\n% reconstruction resulting from FT_SOURCEANALYSIS or FT_SOURCEINTERPOLATE.\n% \n% The configuration can contain\n%   cfg.downsample = integer number (default = 1, i.e. no downsampling)\n%   cfg.smooth     = 'no' or the FWHM of the gaussian kernel in voxels (default = 'no')\n\n----------------------------------------------\n\n\n----------------------------------------------\n\n% Use as\n%   [mri] = ft_volumenormalise(cfg, mri)\n% where the input mri should be a single anatomical volume that was for\n% example read with FT_READ_MRI. \n\n----------------------------------------------\n\n% Use as\n%   [mri] = ft_volumerealign(cfg, mri)\n% where the input mri should be a single anatomical or functional MRI\n% volume that was for example read with FT_READ_MRI.\n\n----------------------------------------------\n\n% Use as\n%   mri = ft_volumereslice(cfg, mri)\n% where the input mri should be a single anatomical or functional MRI\n% volume that was for example read with FT_READ_MRI.\n\n----------------------------------------------\n\n% Use as\n%   segment = ft_volumesegment(cfg, mri)\n% where the input mri should be a single anatomical volume that was for\n% example read with FT_READ_MRI. You can also provide an already segmented\n% volume as input for the purpose of creating a binary mask.\n\n----------------------------------------------\n\n% Use as\n%   ft_volumewrite(cfg, volume)\n% where the input volume structure should represent an anatomical MRI\n% that was for example obtained from FT_READ_MRI, the source\n% reconstruction results from FT_SOURCEANALYSIS, the statistical\n% results from FT_SOURCESTATISTICS or an otherwise processed anatomical\n% or functional volume.\n\n----------------------------------------------\n\n% Use as\n%   ft_wizard scriptname\n% or \n%   ft_wizard('scriptname')"
      - +@isprivate: "0"
        commentid: "7443"
        comment_count: "4"
        who:
          +content: r.oostenveld
          +@name: Robert Oostenveld
        bug_when: 2012-09-19 22:27:07 +0200
        thetext: '*** Bug 1077 has been marked as a duplicate of this bug. ***'
